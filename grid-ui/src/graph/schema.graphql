# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

"columns and relationships of \"activities\""
type activities {
    "An array relationship"
    activity_assets(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): [activity_asset!]!
    "An aggregate relationship"
    activity_assets_aggregate(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): activity_asset_aggregate!
    created_at: timestamptz!
    created_by: Int!
    "An object relationship"
    created_by_object: users!
    id: Int!
    is_hidden: Boolean!
    notes: String
    source: String
    "An array relationship"
    task_activities(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): [task_activity!]!
    "An aggregate relationship"
    task_activities_aggregate(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): task_activity_aggregate!
    timestamp: timestamptz
    type: activity_type_enum
    updated_at: timestamptz!
}

"aggregated selection of \"activities\""
type activities_aggregate {
    aggregate: activities_aggregate_fields
    nodes: [activities!]!
}

"aggregate fields of \"activities\""
type activities_aggregate_fields {
    avg: activities_avg_fields
    count(columns: [activities_select_column!], distinct: Boolean): Int!
    max: activities_max_fields
    min: activities_min_fields
    stddev: activities_stddev_fields
    stddev_pop: activities_stddev_pop_fields
    stddev_samp: activities_stddev_samp_fields
    sum: activities_sum_fields
    var_pop: activities_var_pop_fields
    var_samp: activities_var_samp_fields
    variance: activities_variance_fields
}

"aggregate avg on columns"
type activities_avg_fields {
    created_by: Float
    id: Float
}

"aggregate max on columns"
type activities_max_fields {
    created_at: timestamptz
    created_by: Int
    id: Int
    notes: String
    source: String
    timestamp: timestamptz
    updated_at: timestamptz
}

"aggregate min on columns"
type activities_min_fields {
    created_at: timestamptz
    created_by: Int
    id: Int
    notes: String
    source: String
    timestamp: timestamptz
    updated_at: timestamptz
}

"response of any mutation on the table \"activities\""
type activities_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [activities!]!
}

"aggregate stddev on columns"
type activities_stddev_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_pop on columns"
type activities_stddev_pop_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_samp on columns"
type activities_stddev_samp_fields {
    created_by: Float
    id: Float
}

"aggregate sum on columns"
type activities_sum_fields {
    created_by: Int
    id: Int
}

"aggregate var_pop on columns"
type activities_var_pop_fields {
    created_by: Float
    id: Float
}

"aggregate var_samp on columns"
type activities_var_samp_fields {
    created_by: Float
    id: Float
}

"aggregate variance on columns"
type activities_variance_fields {
    created_by: Float
    id: Float
}

"columns and relationships of \"activity_asset\""
type activity_asset {
    "An object relationship"
    activity: activities!
    activity_id: Int!
    "An object relationship"
    asset: assets!
    asset_id: Int!
}

"aggregated selection of \"activity_asset\""
type activity_asset_aggregate {
    aggregate: activity_asset_aggregate_fields
    nodes: [activity_asset!]!
}

"aggregate fields of \"activity_asset\""
type activity_asset_aggregate_fields {
    avg: activity_asset_avg_fields
    count(columns: [activity_asset_select_column!], distinct: Boolean): Int!
    max: activity_asset_max_fields
    min: activity_asset_min_fields
    stddev: activity_asset_stddev_fields
    stddev_pop: activity_asset_stddev_pop_fields
    stddev_samp: activity_asset_stddev_samp_fields
    sum: activity_asset_sum_fields
    var_pop: activity_asset_var_pop_fields
    var_samp: activity_asset_var_samp_fields
    variance: activity_asset_variance_fields
}

"aggregate avg on columns"
type activity_asset_avg_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate max on columns"
type activity_asset_max_fields {
    activity_id: Int
    asset_id: Int
}

"aggregate min on columns"
type activity_asset_min_fields {
    activity_id: Int
    asset_id: Int
}

"response of any mutation on the table \"activity_asset\""
type activity_asset_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [activity_asset!]!
}

"aggregate stddev on columns"
type activity_asset_stddev_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate stddev_pop on columns"
type activity_asset_stddev_pop_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate stddev_samp on columns"
type activity_asset_stddev_samp_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate sum on columns"
type activity_asset_sum_fields {
    activity_id: Int
    asset_id: Int
}

"aggregate var_pop on columns"
type activity_asset_var_pop_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate var_samp on columns"
type activity_asset_var_samp_fields {
    activity_id: Float
    asset_id: Float
}

"aggregate variance on columns"
type activity_asset_variance_fields {
    activity_id: Float
    asset_id: Float
}

"columns and relationships of \"activity_type\""
type activity_type {
    comment: String
    value: String!
}

"aggregated selection of \"activity_type\""
type activity_type_aggregate {
    aggregate: activity_type_aggregate_fields
    nodes: [activity_type!]!
}

"aggregate fields of \"activity_type\""
type activity_type_aggregate_fields {
    count(columns: [activity_type_select_column!], distinct: Boolean): Int!
    max: activity_type_max_fields
    min: activity_type_min_fields
}

"aggregate max on columns"
type activity_type_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type activity_type_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"activity_type\""
type activity_type_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [activity_type!]!
}

"columns and relationships of \"asset_category\""
type asset_category {
    comment: String
    value: String!
}

"aggregated selection of \"asset_category\""
type asset_category_aggregate {
    aggregate: asset_category_aggregate_fields
    nodes: [asset_category!]!
}

"aggregate fields of \"asset_category\""
type asset_category_aggregate_fields {
    count(columns: [asset_category_select_column!], distinct: Boolean): Int!
    max: asset_category_max_fields
    min: asset_category_min_fields
}

"aggregate max on columns"
type asset_category_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type asset_category_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"asset_category\""
type asset_category_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [asset_category!]!
}

"columns and relationships of \"assets\""
type assets {
    "An array relationship"
    activity_assets(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): [activity_asset!]!
    "An aggregate relationship"
    activity_assets_aggregate(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): activity_asset_aggregate!
    category: asset_category_enum!
    created_at: timestamptz!
    created_by: Int!
    "An object relationship"
    created_by_object: users!
    description: String
    id: Int!
    name: String!
    updated_at: timestamptz!
    url: String
}

"aggregated selection of \"assets\""
type assets_aggregate {
    aggregate: assets_aggregate_fields
    nodes: [assets!]!
}

"aggregate fields of \"assets\""
type assets_aggregate_fields {
    avg: assets_avg_fields
    count(columns: [assets_select_column!], distinct: Boolean): Int!
    max: assets_max_fields
    min: assets_min_fields
    stddev: assets_stddev_fields
    stddev_pop: assets_stddev_pop_fields
    stddev_samp: assets_stddev_samp_fields
    sum: assets_sum_fields
    var_pop: assets_var_pop_fields
    var_samp: assets_var_samp_fields
    variance: assets_variance_fields
}

"aggregate avg on columns"
type assets_avg_fields {
    created_by: Float
    id: Float
}

"aggregate max on columns"
type assets_max_fields {
    created_at: timestamptz
    created_by: Int
    description: String
    id: Int
    name: String
    updated_at: timestamptz
    url: String
}

"aggregate min on columns"
type assets_min_fields {
    created_at: timestamptz
    created_by: Int
    description: String
    id: Int
    name: String
    updated_at: timestamptz
    url: String
}

"response of any mutation on the table \"assets\""
type assets_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [assets!]!
}

"aggregate stddev on columns"
type assets_stddev_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_pop on columns"
type assets_stddev_pop_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_samp on columns"
type assets_stddev_samp_fields {
    created_by: Float
    id: Float
}

"aggregate sum on columns"
type assets_sum_fields {
    created_by: Int
    id: Int
}

"aggregate var_pop on columns"
type assets_var_pop_fields {
    created_by: Float
    id: Float
}

"aggregate var_samp on columns"
type assets_var_samp_fields {
    created_by: Float
    id: Float
}

"aggregate variance on columns"
type assets_variance_fields {
    created_by: Float
    id: Float
}

"mutation root"
type mutation_root {
    "delete data from the table: \"activities\""
    delete_activities(
        "filter the rows which have to be deleted"
        where: activities_bool_exp!
    ): activities_mutation_response
    "delete single row from the table: \"activities\""
    delete_activities_by_pk(id: Int!): activities
    "delete data from the table: \"activity_asset\""
    delete_activity_asset(
        "filter the rows which have to be deleted"
        where: activity_asset_bool_exp!
    ): activity_asset_mutation_response
    "delete single row from the table: \"activity_asset\""
    delete_activity_asset_by_pk(activity_id: Int!, asset_id: Int!): activity_asset
    "delete data from the table: \"activity_type\""
    delete_activity_type(
        "filter the rows which have to be deleted"
        where: activity_type_bool_exp!
    ): activity_type_mutation_response
    "delete single row from the table: \"activity_type\""
    delete_activity_type_by_pk(value: String!): activity_type
    "delete data from the table: \"asset_category\""
    delete_asset_category(
        "filter the rows which have to be deleted"
        where: asset_category_bool_exp!
    ): asset_category_mutation_response
    "delete single row from the table: \"asset_category\""
    delete_asset_category_by_pk(value: String!): asset_category
    "delete data from the table: \"assets\""
    delete_assets(
        "filter the rows which have to be deleted"
        where: assets_bool_exp!
    ): assets_mutation_response
    "delete single row from the table: \"assets\""
    delete_assets_by_pk(id: Int!): assets
    "delete data from the table: \"task_activity\""
    delete_task_activity(
        "filter the rows which have to be deleted"
        where: task_activity_bool_exp!
    ): task_activity_mutation_response
    "delete single row from the table: \"task_activity\""
    delete_task_activity_by_pk(activity_id: Int!, task_id: Int!): task_activity
    "delete data from the table: \"task_status\""
    delete_task_status(
        "filter the rows which have to be deleted"
        where: task_status_bool_exp!
    ): task_status_mutation_response
    "delete single row from the table: \"task_status\""
    delete_task_status_by_pk(value: String!): task_status
    "delete data from the table: \"tasks\""
    delete_tasks(
        "filter the rows which have to be deleted"
        where: tasks_bool_exp!
    ): tasks_mutation_response
    "delete single row from the table: \"tasks\""
    delete_tasks_by_pk(id: Int!): tasks
    "delete data from the table: \"user_role\""
    delete_user_role(
        "filter the rows which have to be deleted"
        where: user_role_bool_exp!
    ): user_role_mutation_response
    "delete single row from the table: \"user_role\""
    delete_user_role_by_pk(value: String!): user_role
    "delete data from the table: \"users\""
    delete_users(
        "filter the rows which have to be deleted"
        where: users_bool_exp!
    ): users_mutation_response
    "delete single row from the table: \"users\""
    delete_users_by_pk(id: Int!): users
    "insert data into the table: \"activities\""
    insert_activities(
        "the rows to be inserted"
        objects: [activities_insert_input!]!,
        "upsert condition"
        on_conflict: activities_on_conflict
    ): activities_mutation_response
    "insert a single row into the table: \"activities\""
    insert_activities_one(
        "the row to be inserted"
        object: activities_insert_input!,
        "upsert condition"
        on_conflict: activities_on_conflict
    ): activities
    "insert data into the table: \"activity_asset\""
    insert_activity_asset(
        "the rows to be inserted"
        objects: [activity_asset_insert_input!]!,
        "upsert condition"
        on_conflict: activity_asset_on_conflict
    ): activity_asset_mutation_response
    "insert a single row into the table: \"activity_asset\""
    insert_activity_asset_one(
        "the row to be inserted"
        object: activity_asset_insert_input!,
        "upsert condition"
        on_conflict: activity_asset_on_conflict
    ): activity_asset
    "insert data into the table: \"activity_type\""
    insert_activity_type(
        "the rows to be inserted"
        objects: [activity_type_insert_input!]!,
        "upsert condition"
        on_conflict: activity_type_on_conflict
    ): activity_type_mutation_response
    "insert a single row into the table: \"activity_type\""
    insert_activity_type_one(
        "the row to be inserted"
        object: activity_type_insert_input!,
        "upsert condition"
        on_conflict: activity_type_on_conflict
    ): activity_type
    "insert data into the table: \"asset_category\""
    insert_asset_category(
        "the rows to be inserted"
        objects: [asset_category_insert_input!]!,
        "upsert condition"
        on_conflict: asset_category_on_conflict
    ): asset_category_mutation_response
    "insert a single row into the table: \"asset_category\""
    insert_asset_category_one(
        "the row to be inserted"
        object: asset_category_insert_input!,
        "upsert condition"
        on_conflict: asset_category_on_conflict
    ): asset_category
    "insert data into the table: \"assets\""
    insert_assets(
        "the rows to be inserted"
        objects: [assets_insert_input!]!,
        "upsert condition"
        on_conflict: assets_on_conflict
    ): assets_mutation_response
    "insert a single row into the table: \"assets\""
    insert_assets_one(
        "the row to be inserted"
        object: assets_insert_input!,
        "upsert condition"
        on_conflict: assets_on_conflict
    ): assets
    "insert data into the table: \"task_activity\""
    insert_task_activity(
        "the rows to be inserted"
        objects: [task_activity_insert_input!]!,
        "upsert condition"
        on_conflict: task_activity_on_conflict
    ): task_activity_mutation_response
    "insert a single row into the table: \"task_activity\""
    insert_task_activity_one(
        "the row to be inserted"
        object: task_activity_insert_input!,
        "upsert condition"
        on_conflict: task_activity_on_conflict
    ): task_activity
    "insert data into the table: \"task_status\""
    insert_task_status(
        "the rows to be inserted"
        objects: [task_status_insert_input!]!,
        "upsert condition"
        on_conflict: task_status_on_conflict
    ): task_status_mutation_response
    "insert a single row into the table: \"task_status\""
    insert_task_status_one(
        "the row to be inserted"
        object: task_status_insert_input!,
        "upsert condition"
        on_conflict: task_status_on_conflict
    ): task_status
    "insert data into the table: \"tasks\""
    insert_tasks(
        "the rows to be inserted"
        objects: [tasks_insert_input!]!,
        "upsert condition"
        on_conflict: tasks_on_conflict
    ): tasks_mutation_response
    "insert a single row into the table: \"tasks\""
    insert_tasks_one(
        "the row to be inserted"
        object: tasks_insert_input!,
        "upsert condition"
        on_conflict: tasks_on_conflict
    ): tasks
    "insert data into the table: \"user_role\""
    insert_user_role(
        "the rows to be inserted"
        objects: [user_role_insert_input!]!,
        "upsert condition"
        on_conflict: user_role_on_conflict
    ): user_role_mutation_response
    "insert a single row into the table: \"user_role\""
    insert_user_role_one(
        "the row to be inserted"
        object: user_role_insert_input!,
        "upsert condition"
        on_conflict: user_role_on_conflict
    ): user_role
    "insert data into the table: \"users\""
    insert_users(
        "the rows to be inserted"
        objects: [users_insert_input!]!,
        "upsert condition"
        on_conflict: users_on_conflict
    ): users_mutation_response
    "insert a single row into the table: \"users\""
    insert_users_one(
        "the row to be inserted"
        object: users_insert_input!,
        "upsert condition"
        on_conflict: users_on_conflict
    ): users
    "update data of the table: \"activities\""
    update_activities(
        "increments the numeric columns with given value of the filtered values"
        _inc: activities_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: activities_set_input,
        "filter the rows which have to be updated"
        where: activities_bool_exp!
    ): activities_mutation_response
    "update single row of the table: \"activities\""
    update_activities_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: activities_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: activities_set_input,
        pk_columns: activities_pk_columns_input!
    ): activities
    "update multiples rows of table: \"activities\""
    update_activities_many(
        "updates to execute, in order"
        updates: [activities_updates!]!
    ): [activities_mutation_response]
    "update data of the table: \"activity_asset\""
    update_activity_asset(
        "increments the numeric columns with given value of the filtered values"
        _inc: activity_asset_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: activity_asset_set_input,
        "filter the rows which have to be updated"
        where: activity_asset_bool_exp!
    ): activity_asset_mutation_response
    "update single row of the table: \"activity_asset\""
    update_activity_asset_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: activity_asset_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: activity_asset_set_input,
        pk_columns: activity_asset_pk_columns_input!
    ): activity_asset
    "update multiples rows of table: \"activity_asset\""
    update_activity_asset_many(
        "updates to execute, in order"
        updates: [activity_asset_updates!]!
    ): [activity_asset_mutation_response]
    "update data of the table: \"activity_type\""
    update_activity_type(
        "sets the columns of the filtered rows to the given values"
        _set: activity_type_set_input,
        "filter the rows which have to be updated"
        where: activity_type_bool_exp!
    ): activity_type_mutation_response
    "update single row of the table: \"activity_type\""
    update_activity_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: activity_type_set_input,
        pk_columns: activity_type_pk_columns_input!
    ): activity_type
    "update multiples rows of table: \"activity_type\""
    update_activity_type_many(
        "updates to execute, in order"
        updates: [activity_type_updates!]!
    ): [activity_type_mutation_response]
    "update data of the table: \"asset_category\""
    update_asset_category(
        "sets the columns of the filtered rows to the given values"
        _set: asset_category_set_input,
        "filter the rows which have to be updated"
        where: asset_category_bool_exp!
    ): asset_category_mutation_response
    "update single row of the table: \"asset_category\""
    update_asset_category_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: asset_category_set_input,
        pk_columns: asset_category_pk_columns_input!
    ): asset_category
    "update multiples rows of table: \"asset_category\""
    update_asset_category_many(
        "updates to execute, in order"
        updates: [asset_category_updates!]!
    ): [asset_category_mutation_response]
    "update data of the table: \"assets\""
    update_assets(
        "increments the numeric columns with given value of the filtered values"
        _inc: assets_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: assets_set_input,
        "filter the rows which have to be updated"
        where: assets_bool_exp!
    ): assets_mutation_response
    "update single row of the table: \"assets\""
    update_assets_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: assets_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: assets_set_input,
        pk_columns: assets_pk_columns_input!
    ): assets
    "update multiples rows of table: \"assets\""
    update_assets_many(
        "updates to execute, in order"
        updates: [assets_updates!]!
    ): [assets_mutation_response]
    "update data of the table: \"task_activity\""
    update_task_activity(
        "increments the numeric columns with given value of the filtered values"
        _inc: task_activity_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: task_activity_set_input,
        "filter the rows which have to be updated"
        where: task_activity_bool_exp!
    ): task_activity_mutation_response
    "update single row of the table: \"task_activity\""
    update_task_activity_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: task_activity_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: task_activity_set_input,
        pk_columns: task_activity_pk_columns_input!
    ): task_activity
    "update multiples rows of table: \"task_activity\""
    update_task_activity_many(
        "updates to execute, in order"
        updates: [task_activity_updates!]!
    ): [task_activity_mutation_response]
    "update data of the table: \"task_status\""
    update_task_status(
        "sets the columns of the filtered rows to the given values"
        _set: task_status_set_input,
        "filter the rows which have to be updated"
        where: task_status_bool_exp!
    ): task_status_mutation_response
    "update single row of the table: \"task_status\""
    update_task_status_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: task_status_set_input,
        pk_columns: task_status_pk_columns_input!
    ): task_status
    "update multiples rows of table: \"task_status\""
    update_task_status_many(
        "updates to execute, in order"
        updates: [task_status_updates!]!
    ): [task_status_mutation_response]
    "update data of the table: \"tasks\""
    update_tasks(
        "increments the numeric columns with given value of the filtered values"
        _inc: tasks_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: tasks_set_input,
        "filter the rows which have to be updated"
        where: tasks_bool_exp!
    ): tasks_mutation_response
    "update single row of the table: \"tasks\""
    update_tasks_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: tasks_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: tasks_set_input,
        pk_columns: tasks_pk_columns_input!
    ): tasks
    "update multiples rows of table: \"tasks\""
    update_tasks_many(
        "updates to execute, in order"
        updates: [tasks_updates!]!
    ): [tasks_mutation_response]
    "update data of the table: \"user_role\""
    update_user_role(
        "sets the columns of the filtered rows to the given values"
        _set: user_role_set_input,
        "filter the rows which have to be updated"
        where: user_role_bool_exp!
    ): user_role_mutation_response
    "update single row of the table: \"user_role\""
    update_user_role_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: user_role_set_input,
        pk_columns: user_role_pk_columns_input!
    ): user_role
    "update multiples rows of table: \"user_role\""
    update_user_role_many(
        "updates to execute, in order"
        updates: [user_role_updates!]!
    ): [user_role_mutation_response]
    "update data of the table: \"users\""
    update_users(
        "increments the numeric columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        "filter the rows which have to be updated"
        where: users_bool_exp!
    ): users_mutation_response
    "update single row of the table: \"users\""
    update_users_by_pk(
        "increments the numeric columns with given value of the filtered values"
        _inc: users_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        pk_columns: users_pk_columns_input!
    ): users
    "update multiples rows of table: \"users\""
    update_users_many(
        "updates to execute, in order"
        updates: [users_updates!]!
    ): [users_mutation_response]
}

type query_root {
    "An array relationship"
    activities(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): [activities!]!
    "An aggregate relationship"
    activities_aggregate(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): activities_aggregate!
    "fetch data from the table: \"activities\" using primary key columns"
    activities_by_pk(id: Int!): activities
    "fetch data from the table: \"activity_asset\""
    activity_asset(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): [activity_asset!]!
    "fetch aggregated fields from the table: \"activity_asset\""
    activity_asset_aggregate(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): activity_asset_aggregate!
    "fetch data from the table: \"activity_asset\" using primary key columns"
    activity_asset_by_pk(activity_id: Int!, asset_id: Int!): activity_asset
    "fetch data from the table: \"activity_type\""
    activity_type(
        "distinct select on columns"
        distinct_on: [activity_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_type_order_by!],
        "filter the rows returned"
        where: activity_type_bool_exp
    ): [activity_type!]!
    "fetch aggregated fields from the table: \"activity_type\""
    activity_type_aggregate(
        "distinct select on columns"
        distinct_on: [activity_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_type_order_by!],
        "filter the rows returned"
        where: activity_type_bool_exp
    ): activity_type_aggregate!
    "fetch data from the table: \"activity_type\" using primary key columns"
    activity_type_by_pk(value: String!): activity_type
    "fetch data from the table: \"asset_category\""
    asset_category(
        "distinct select on columns"
        distinct_on: [asset_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [asset_category_order_by!],
        "filter the rows returned"
        where: asset_category_bool_exp
    ): [asset_category!]!
    "fetch aggregated fields from the table: \"asset_category\""
    asset_category_aggregate(
        "distinct select on columns"
        distinct_on: [asset_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [asset_category_order_by!],
        "filter the rows returned"
        where: asset_category_bool_exp
    ): asset_category_aggregate!
    "fetch data from the table: \"asset_category\" using primary key columns"
    asset_category_by_pk(value: String!): asset_category
    "An array relationship"
    assets(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): [assets!]!
    "An aggregate relationship"
    assets_aggregate(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): assets_aggregate!
    "fetch data from the table: \"assets\" using primary key columns"
    assets_by_pk(id: Int!): assets
    "fetch data from the table: \"task_activity\""
    task_activity(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): [task_activity!]!
    "fetch aggregated fields from the table: \"task_activity\""
    task_activity_aggregate(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): task_activity_aggregate!
    "fetch data from the table: \"task_activity\" using primary key columns"
    task_activity_by_pk(activity_id: Int!, task_id: Int!): task_activity
    "fetch data from the table: \"task_status\""
    task_status(
        "distinct select on columns"
        distinct_on: [task_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_status_order_by!],
        "filter the rows returned"
        where: task_status_bool_exp
    ): [task_status!]!
    "fetch aggregated fields from the table: \"task_status\""
    task_status_aggregate(
        "distinct select on columns"
        distinct_on: [task_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_status_order_by!],
        "filter the rows returned"
        where: task_status_bool_exp
    ): task_status_aggregate!
    "fetch data from the table: \"task_status\" using primary key columns"
    task_status_by_pk(value: String!): task_status
    "An array relationship"
    tasks(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): [tasks!]!
    "An aggregate relationship"
    tasks_aggregate(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): tasks_aggregate!
    "fetch data from the table: \"tasks\" using primary key columns"
    tasks_by_pk(id: Int!): tasks
    "fetch data from the table: \"user_role\""
    user_role(
        "distinct select on columns"
        distinct_on: [user_role_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_role_order_by!],
        "filter the rows returned"
        where: user_role_bool_exp
    ): [user_role!]!
    "fetch aggregated fields from the table: \"user_role\""
    user_role_aggregate(
        "distinct select on columns"
        distinct_on: [user_role_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_role_order_by!],
        "filter the rows returned"
        where: user_role_bool_exp
    ): user_role_aggregate!
    "fetch data from the table: \"user_role\" using primary key columns"
    user_role_by_pk(value: String!): user_role
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: Int!): users
}

type subscription_root {
    "An array relationship"
    activities(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): [activities!]!
    "An aggregate relationship"
    activities_aggregate(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): activities_aggregate!
    "fetch data from the table: \"activities\" using primary key columns"
    activities_by_pk(id: Int!): activities
    "fetch data from the table in a streaming manner: \"activities\""
    activities_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [activities_stream_cursor_input]!,
        "filter the rows returned"
        where: activities_bool_exp
    ): [activities!]!
    "fetch data from the table: \"activity_asset\""
    activity_asset(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): [activity_asset!]!
    "fetch aggregated fields from the table: \"activity_asset\""
    activity_asset_aggregate(
        "distinct select on columns"
        distinct_on: [activity_asset_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_asset_order_by!],
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): activity_asset_aggregate!
    "fetch data from the table: \"activity_asset\" using primary key columns"
    activity_asset_by_pk(activity_id: Int!, asset_id: Int!): activity_asset
    "fetch data from the table in a streaming manner: \"activity_asset\""
    activity_asset_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [activity_asset_stream_cursor_input]!,
        "filter the rows returned"
        where: activity_asset_bool_exp
    ): [activity_asset!]!
    "fetch data from the table: \"activity_type\""
    activity_type(
        "distinct select on columns"
        distinct_on: [activity_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_type_order_by!],
        "filter the rows returned"
        where: activity_type_bool_exp
    ): [activity_type!]!
    "fetch aggregated fields from the table: \"activity_type\""
    activity_type_aggregate(
        "distinct select on columns"
        distinct_on: [activity_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activity_type_order_by!],
        "filter the rows returned"
        where: activity_type_bool_exp
    ): activity_type_aggregate!
    "fetch data from the table: \"activity_type\" using primary key columns"
    activity_type_by_pk(value: String!): activity_type
    "fetch data from the table in a streaming manner: \"activity_type\""
    activity_type_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [activity_type_stream_cursor_input]!,
        "filter the rows returned"
        where: activity_type_bool_exp
    ): [activity_type!]!
    "fetch data from the table: \"asset_category\""
    asset_category(
        "distinct select on columns"
        distinct_on: [asset_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [asset_category_order_by!],
        "filter the rows returned"
        where: asset_category_bool_exp
    ): [asset_category!]!
    "fetch aggregated fields from the table: \"asset_category\""
    asset_category_aggregate(
        "distinct select on columns"
        distinct_on: [asset_category_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [asset_category_order_by!],
        "filter the rows returned"
        where: asset_category_bool_exp
    ): asset_category_aggregate!
    "fetch data from the table: \"asset_category\" using primary key columns"
    asset_category_by_pk(value: String!): asset_category
    "fetch data from the table in a streaming manner: \"asset_category\""
    asset_category_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [asset_category_stream_cursor_input]!,
        "filter the rows returned"
        where: asset_category_bool_exp
    ): [asset_category!]!
    "An array relationship"
    assets(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): [assets!]!
    "An aggregate relationship"
    assets_aggregate(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): assets_aggregate!
    "fetch data from the table: \"assets\" using primary key columns"
    assets_by_pk(id: Int!): assets
    "fetch data from the table in a streaming manner: \"assets\""
    assets_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [assets_stream_cursor_input]!,
        "filter the rows returned"
        where: assets_bool_exp
    ): [assets!]!
    "fetch data from the table: \"task_activity\""
    task_activity(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): [task_activity!]!
    "fetch aggregated fields from the table: \"task_activity\""
    task_activity_aggregate(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): task_activity_aggregate!
    "fetch data from the table: \"task_activity\" using primary key columns"
    task_activity_by_pk(activity_id: Int!, task_id: Int!): task_activity
    "fetch data from the table in a streaming manner: \"task_activity\""
    task_activity_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [task_activity_stream_cursor_input]!,
        "filter the rows returned"
        where: task_activity_bool_exp
    ): [task_activity!]!
    "fetch data from the table: \"task_status\""
    task_status(
        "distinct select on columns"
        distinct_on: [task_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_status_order_by!],
        "filter the rows returned"
        where: task_status_bool_exp
    ): [task_status!]!
    "fetch aggregated fields from the table: \"task_status\""
    task_status_aggregate(
        "distinct select on columns"
        distinct_on: [task_status_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_status_order_by!],
        "filter the rows returned"
        where: task_status_bool_exp
    ): task_status_aggregate!
    "fetch data from the table: \"task_status\" using primary key columns"
    task_status_by_pk(value: String!): task_status
    "fetch data from the table in a streaming manner: \"task_status\""
    task_status_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [task_status_stream_cursor_input]!,
        "filter the rows returned"
        where: task_status_bool_exp
    ): [task_status!]!
    "An array relationship"
    tasks(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): [tasks!]!
    "An aggregate relationship"
    tasks_aggregate(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): tasks_aggregate!
    "fetch data from the table: \"tasks\" using primary key columns"
    tasks_by_pk(id: Int!): tasks
    "fetch data from the table in a streaming manner: \"tasks\""
    tasks_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [tasks_stream_cursor_input]!,
        "filter the rows returned"
        where: tasks_bool_exp
    ): [tasks!]!
    "fetch data from the table: \"user_role\""
    user_role(
        "distinct select on columns"
        distinct_on: [user_role_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_role_order_by!],
        "filter the rows returned"
        where: user_role_bool_exp
    ): [user_role!]!
    "fetch aggregated fields from the table: \"user_role\""
    user_role_aggregate(
        "distinct select on columns"
        distinct_on: [user_role_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [user_role_order_by!],
        "filter the rows returned"
        where: user_role_bool_exp
    ): user_role_aggregate!
    "fetch data from the table: \"user_role\" using primary key columns"
    user_role_by_pk(value: String!): user_role
    "fetch data from the table in a streaming manner: \"user_role\""
    user_role_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [user_role_stream_cursor_input]!,
        "filter the rows returned"
        where: user_role_bool_exp
    ): [user_role!]!
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: Int!): users
    "fetch data from the table in a streaming manner: \"users\""
    users_stream(
        "maximum number of rows returned in a single batch"
        batch_size: Int!,
        "cursor to stream the results returned by the query"
        cursor: [users_stream_cursor_input]!,
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
}

"columns and relationships of \"task_activity\""
type task_activity {
    "An object relationship"
    activity: activities!
    activity_id: Int!
    "An object relationship"
    task: tasks!
    task_id: Int!
}

"aggregated selection of \"task_activity\""
type task_activity_aggregate {
    aggregate: task_activity_aggregate_fields
    nodes: [task_activity!]!
}

"aggregate fields of \"task_activity\""
type task_activity_aggregate_fields {
    avg: task_activity_avg_fields
    count(columns: [task_activity_select_column!], distinct: Boolean): Int!
    max: task_activity_max_fields
    min: task_activity_min_fields
    stddev: task_activity_stddev_fields
    stddev_pop: task_activity_stddev_pop_fields
    stddev_samp: task_activity_stddev_samp_fields
    sum: task_activity_sum_fields
    var_pop: task_activity_var_pop_fields
    var_samp: task_activity_var_samp_fields
    variance: task_activity_variance_fields
}

"aggregate avg on columns"
type task_activity_avg_fields {
    activity_id: Float
    task_id: Float
}

"aggregate max on columns"
type task_activity_max_fields {
    activity_id: Int
    task_id: Int
}

"aggregate min on columns"
type task_activity_min_fields {
    activity_id: Int
    task_id: Int
}

"response of any mutation on the table \"task_activity\""
type task_activity_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [task_activity!]!
}

"aggregate stddev on columns"
type task_activity_stddev_fields {
    activity_id: Float
    task_id: Float
}

"aggregate stddev_pop on columns"
type task_activity_stddev_pop_fields {
    activity_id: Float
    task_id: Float
}

"aggregate stddev_samp on columns"
type task_activity_stddev_samp_fields {
    activity_id: Float
    task_id: Float
}

"aggregate sum on columns"
type task_activity_sum_fields {
    activity_id: Int
    task_id: Int
}

"aggregate var_pop on columns"
type task_activity_var_pop_fields {
    activity_id: Float
    task_id: Float
}

"aggregate var_samp on columns"
type task_activity_var_samp_fields {
    activity_id: Float
    task_id: Float
}

"aggregate variance on columns"
type task_activity_variance_fields {
    activity_id: Float
    task_id: Float
}

"columns and relationships of \"task_status\""
type task_status {
    comment: String
    value: String!
}

"aggregated selection of \"task_status\""
type task_status_aggregate {
    aggregate: task_status_aggregate_fields
    nodes: [task_status!]!
}

"aggregate fields of \"task_status\""
type task_status_aggregate_fields {
    count(columns: [task_status_select_column!], distinct: Boolean): Int!
    max: task_status_max_fields
    min: task_status_min_fields
}

"aggregate max on columns"
type task_status_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type task_status_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"task_status\""
type task_status_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [task_status!]!
}

"columns and relationships of \"tasks\""
type tasks {
    created_at: timestamptz!
    created_by: Int!
    "An object relationship"
    created_by_object: users!
    desc: String
    id: Int!
    status: task_status_enum!
    "An array relationship"
    task_activities(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): [task_activity!]!
    "An aggregate relationship"
    task_activities_aggregate(
        "distinct select on columns"
        distinct_on: [task_activity_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [task_activity_order_by!],
        "filter the rows returned"
        where: task_activity_bool_exp
    ): task_activity_aggregate!
    title: String!
    updated_at: timestamptz!
}

"aggregated selection of \"tasks\""
type tasks_aggregate {
    aggregate: tasks_aggregate_fields
    nodes: [tasks!]!
}

"aggregate fields of \"tasks\""
type tasks_aggregate_fields {
    avg: tasks_avg_fields
    count(columns: [tasks_select_column!], distinct: Boolean): Int!
    max: tasks_max_fields
    min: tasks_min_fields
    stddev: tasks_stddev_fields
    stddev_pop: tasks_stddev_pop_fields
    stddev_samp: tasks_stddev_samp_fields
    sum: tasks_sum_fields
    var_pop: tasks_var_pop_fields
    var_samp: tasks_var_samp_fields
    variance: tasks_variance_fields
}

"aggregate avg on columns"
type tasks_avg_fields {
    created_by: Float
    id: Float
}

"aggregate max on columns"
type tasks_max_fields {
    created_at: timestamptz
    created_by: Int
    desc: String
    id: Int
    title: String
    updated_at: timestamptz
}

"aggregate min on columns"
type tasks_min_fields {
    created_at: timestamptz
    created_by: Int
    desc: String
    id: Int
    title: String
    updated_at: timestamptz
}

"response of any mutation on the table \"tasks\""
type tasks_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [tasks!]!
}

"aggregate stddev on columns"
type tasks_stddev_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_pop on columns"
type tasks_stddev_pop_fields {
    created_by: Float
    id: Float
}

"aggregate stddev_samp on columns"
type tasks_stddev_samp_fields {
    created_by: Float
    id: Float
}

"aggregate sum on columns"
type tasks_sum_fields {
    created_by: Int
    id: Int
}

"aggregate var_pop on columns"
type tasks_var_pop_fields {
    created_by: Float
    id: Float
}

"aggregate var_samp on columns"
type tasks_var_samp_fields {
    created_by: Float
    id: Float
}

"aggregate variance on columns"
type tasks_variance_fields {
    created_by: Float
    id: Float
}

"columns and relationships of \"user_role\""
type user_role {
    comment: String
    value: String!
}

"aggregated selection of \"user_role\""
type user_role_aggregate {
    aggregate: user_role_aggregate_fields
    nodes: [user_role!]!
}

"aggregate fields of \"user_role\""
type user_role_aggregate_fields {
    count(columns: [user_role_select_column!], distinct: Boolean): Int!
    max: user_role_max_fields
    min: user_role_min_fields
}

"aggregate max on columns"
type user_role_max_fields {
    comment: String
    value: String
}

"aggregate min on columns"
type user_role_min_fields {
    comment: String
    value: String
}

"response of any mutation on the table \"user_role\""
type user_role_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [user_role!]!
}

"columns and relationships of \"users\""
type users {
    "An array relationship"
    activities(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): [activities!]!
    "An aggregate relationship"
    activities_aggregate(
        "distinct select on columns"
        distinct_on: [activities_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [activities_order_by!],
        "filter the rows returned"
        where: activities_bool_exp
    ): activities_aggregate!
    "An array relationship"
    assets(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): [assets!]!
    "An aggregate relationship"
    assets_aggregate(
        "distinct select on columns"
        distinct_on: [assets_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [assets_order_by!],
        "filter the rows returned"
        where: assets_bool_exp
    ): assets_aggregate!
    created_at: timestamptz!
    id: Int!
    last_login: timestamptz
    name: String
    password: String!
    role: user_role_enum!
    "An array relationship"
    tasks(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): [tasks!]!
    "An aggregate relationship"
    tasks_aggregate(
        "distinct select on columns"
        distinct_on: [tasks_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [tasks_order_by!],
        "filter the rows returned"
        where: tasks_bool_exp
    ): tasks_aggregate!
    updated_at: timestamptz!
    username: String!
}

"aggregated selection of \"users\""
type users_aggregate {
    aggregate: users_aggregate_fields
    nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
    avg: users_avg_fields
    count(columns: [users_select_column!], distinct: Boolean): Int!
    max: users_max_fields
    min: users_min_fields
    stddev: users_stddev_fields
    stddev_pop: users_stddev_pop_fields
    stddev_samp: users_stddev_samp_fields
    sum: users_sum_fields
    var_pop: users_var_pop_fields
    var_samp: users_var_samp_fields
    variance: users_variance_fields
}

"aggregate avg on columns"
type users_avg_fields {
    id: Float
}

"aggregate max on columns"
type users_max_fields {
    created_at: timestamptz
    id: Int
    last_login: timestamptz
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"aggregate min on columns"
type users_min_fields {
    created_at: timestamptz
    id: Int
    last_login: timestamptz
    name: String
    password: String
    updated_at: timestamptz
    username: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
    "number of rows affected by the mutation"
    affected_rows: Int!
    "data from the rows affected by the mutation"
    returning: [users!]!
}

"aggregate stddev on columns"
type users_stddev_fields {
    id: Float
}

"aggregate stddev_pop on columns"
type users_stddev_pop_fields {
    id: Float
}

"aggregate stddev_samp on columns"
type users_stddev_samp_fields {
    id: Float
}

"aggregate sum on columns"
type users_sum_fields {
    id: Int
}

"aggregate var_pop on columns"
type users_var_pop_fields {
    id: Float
}

"aggregate var_samp on columns"
type users_var_samp_fields {
    id: Float
}

"aggregate variance on columns"
type users_variance_fields {
    id: Float
}

"unique or primary key constraints on table \"activities\""
enum activities_constraint {
    "unique or primary key constraint on columns \"id\""
    activities_pkey
}

"select columns of table \"activities\""
enum activities_select_column {
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    id
    "column name"
    is_hidden
    "column name"
    notes
    "column name"
    source
    "column name"
    timestamp
    "column name"
    type
    "column name"
    updated_at
}

"select \"activities_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"activities\""
enum activities_select_column_activities_aggregate_bool_exp_bool_and_arguments_columns {
    "column name"
    is_hidden
}

"select \"activities_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"activities\""
enum activities_select_column_activities_aggregate_bool_exp_bool_or_arguments_columns {
    "column name"
    is_hidden
}

"update columns of table \"activities\""
enum activities_update_column {
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    id
    "column name"
    is_hidden
    "column name"
    notes
    "column name"
    source
    "column name"
    timestamp
    "column name"
    type
    "column name"
    updated_at
}

"unique or primary key constraints on table \"activity_asset\""
enum activity_asset_constraint {
    "unique or primary key constraint on columns \"asset_id\", \"activity_id\""
    activity_asset_pkey
}

"select columns of table \"activity_asset\""
enum activity_asset_select_column {
    "column name"
    activity_id
    "column name"
    asset_id
}

"update columns of table \"activity_asset\""
enum activity_asset_update_column {
    "column name"
    activity_id
    "column name"
    asset_id
}

"unique or primary key constraints on table \"activity_type\""
enum activity_type_constraint {
    "unique or primary key constraint on columns \"value\""
    activity_type_pkey
}

enum activity_type_enum {
    "Read news article on the asset"
    news
    "Did or observed something else related to the asset"
    other
    "Heard podcast about the asset"
    podcast
    "Read blog post on the asset"
    post
    "Observed an update on the asset"
    update
    "Watched video about the asset"
    video
}

"select columns of table \"activity_type\""
enum activity_type_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"activity_type\""
enum activity_type_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"asset_category\""
enum asset_category_constraint {
    "unique or primary key constraint on columns \"value\""
    asset_category_pkey
}

enum asset_category_enum {
    "Cryptocurrency project"
    crypto
    "Fiat or Bitcoin"
    currency
    "Other category"
    other
    "Generic topic"
    topic
}

"select columns of table \"asset_category\""
enum asset_category_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"asset_category\""
enum asset_category_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"assets\""
enum assets_constraint {
    "unique or primary key constraint on columns \"id\""
    assets_pkey
}

"select columns of table \"assets\""
enum assets_select_column {
    "column name"
    category
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    description
    "column name"
    id
    "column name"
    name
    "column name"
    updated_at
    "column name"
    url
}

"update columns of table \"assets\""
enum assets_update_column {
    "column name"
    category
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    description
    "column name"
    id
    "column name"
    name
    "column name"
    updated_at
    "column name"
    url
}

"ordering argument of a cursor"
enum cursor_ordering {
    "ascending ordering of the cursor"
    ASC
    "descending ordering of the cursor"
    DESC
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"task_activity\""
enum task_activity_constraint {
    "unique or primary key constraint on columns \"activity_id\", \"task_id\""
    task_activity_pkey
}

"select columns of table \"task_activity\""
enum task_activity_select_column {
    "column name"
    activity_id
    "column name"
    task_id
}

"update columns of table \"task_activity\""
enum task_activity_update_column {
    "column name"
    activity_id
    "column name"
    task_id
}

"unique or primary key constraints on table \"task_status\""
enum task_status_constraint {
    "unique or primary key constraint on columns \"value\""
    task_status_pkey
}

enum task_status_enum {
    "Archived task"
    archive
    "Task needs more info"
    backlog
    "Task is done"
    done
    "Someone is working on the task"
    inprogress
    "Recurring task"
    recurring
    "To start working on"
    todo
}

"select columns of table \"task_status\""
enum task_status_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"task_status\""
enum task_status_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"tasks\""
enum tasks_constraint {
    "unique or primary key constraint on columns \"id\""
    tasks_pkey
}

"select columns of table \"tasks\""
enum tasks_select_column {
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    desc
    "column name"
    id
    "column name"
    status
    "column name"
    title
    "column name"
    updated_at
}

"update columns of table \"tasks\""
enum tasks_update_column {
    "column name"
    created_at
    "column name"
    created_by
    "column name"
    desc
    "column name"
    id
    "column name"
    status
    "column name"
    title
    "column name"
    updated_at
}

"unique or primary key constraints on table \"user_role\""
enum user_role_constraint {
    "unique or primary key constraint on columns \"value\""
    user_role_pkey
}

enum user_role_enum {
    "Users with the privilege to set users roles"
    admin
    "Ordinary users"
    user
}

"select columns of table \"user_role\""
enum user_role_select_column {
    "column name"
    comment
    "column name"
    value
}

"update columns of table \"user_role\""
enum user_role_update_column {
    "column name"
    comment
    "column name"
    value
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
    "unique or primary key constraint on columns \"id\""
    users_pkey
    "unique or primary key constraint on columns \"username\""
    users_username_key
}

"select columns of table \"users\""
enum users_select_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    last_login
    "column name"
    name
    "column name"
    password
    "column name"
    role
    "column name"
    updated_at
    "column name"
    username
}

"update columns of table \"users\""
enum users_update_column {
    "column name"
    created_at
    "column name"
    id
    "column name"
    last_login
    "column name"
    name
    "column name"
    password
    "column name"
    role
    "column name"
    updated_at
    "column name"
    username
}

scalar timestamptz

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
    _eq: Boolean
    _gt: Boolean
    _gte: Boolean
    _in: [Boolean!]
    _is_null: Boolean
    _lt: Boolean
    _lte: Boolean
    _neq: Boolean
    _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    "does the column match the given case-insensitive pattern"
    _ilike: String
    _in: [String!]
    "does the column match the given POSIX regular expression, case insensitive"
    _iregex: String
    _is_null: Boolean
    "does the column match the given pattern"
    _like: String
    _lt: String
    _lte: String
    _neq: String
    "does the column NOT match the given case-insensitive pattern"
    _nilike: String
    _nin: [String!]
    "does the column NOT match the given POSIX regular expression, case insensitive"
    _niregex: String
    "does the column NOT match the given pattern"
    _nlike: String
    "does the column NOT match the given POSIX regular expression, case sensitive"
    _nregex: String
    "does the column NOT match the given SQL regular expression"
    _nsimilar: String
    "does the column match the given POSIX regular expression, case sensitive"
    _regex: String
    "does the column match the given SQL regular expression"
    _similar: String
}

input activities_aggregate_bool_exp {
    bool_and: activities_aggregate_bool_exp_bool_and
    bool_or: activities_aggregate_bool_exp_bool_or
    count: activities_aggregate_bool_exp_count
}

input activities_aggregate_bool_exp_bool_and {
    arguments: activities_select_column_activities_aggregate_bool_exp_bool_and_arguments_columns!
    distinct: Boolean
    filter: activities_bool_exp
    predicate: Boolean_comparison_exp!
}

input activities_aggregate_bool_exp_bool_or {
    arguments: activities_select_column_activities_aggregate_bool_exp_bool_or_arguments_columns!
    distinct: Boolean
    filter: activities_bool_exp
    predicate: Boolean_comparison_exp!
}

input activities_aggregate_bool_exp_count {
    arguments: [activities_select_column!]
    distinct: Boolean
    filter: activities_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"activities\""
input activities_aggregate_order_by {
    avg: activities_avg_order_by
    count: order_by
    max: activities_max_order_by
    min: activities_min_order_by
    stddev: activities_stddev_order_by
    stddev_pop: activities_stddev_pop_order_by
    stddev_samp: activities_stddev_samp_order_by
    sum: activities_sum_order_by
    var_pop: activities_var_pop_order_by
    var_samp: activities_var_samp_order_by
    variance: activities_variance_order_by
}

"input type for inserting array relation for remote table \"activities\""
input activities_arr_rel_insert_input {
    data: [activities_insert_input!]!
    "upsert condition"
    on_conflict: activities_on_conflict
}

"order by avg() on columns of table \"activities\""
input activities_avg_order_by {
    created_by: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"activities\". All fields are combined with a logical 'AND'."
input activities_bool_exp {
    _and: [activities_bool_exp!]
    _not: activities_bool_exp
    _or: [activities_bool_exp!]
    activity_assets: activity_asset_bool_exp
    activity_assets_aggregate: activity_asset_aggregate_bool_exp
    created_at: timestamptz_comparison_exp
    created_by: Int_comparison_exp
    created_by_object: users_bool_exp
    id: Int_comparison_exp
    is_hidden: Boolean_comparison_exp
    notes: String_comparison_exp
    source: String_comparison_exp
    task_activities: task_activity_bool_exp
    task_activities_aggregate: task_activity_aggregate_bool_exp
    timestamp: timestamptz_comparison_exp
    type: activity_type_enum_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"activities\""
input activities_inc_input {
    created_by: Int
    id: Int
}

"input type for inserting data into table \"activities\""
input activities_insert_input {
    activity_assets: activity_asset_arr_rel_insert_input
    created_at: timestamptz
    created_by: Int
    created_by_object: users_obj_rel_insert_input
    id: Int
    is_hidden: Boolean
    notes: String
    source: String
    task_activities: task_activity_arr_rel_insert_input
    timestamp: timestamptz
    type: activity_type_enum
    updated_at: timestamptz
}

"order by max() on columns of table \"activities\""
input activities_max_order_by {
    created_at: order_by
    created_by: order_by
    id: order_by
    notes: order_by
    source: order_by
    timestamp: order_by
    updated_at: order_by
}

"order by min() on columns of table \"activities\""
input activities_min_order_by {
    created_at: order_by
    created_by: order_by
    id: order_by
    notes: order_by
    source: order_by
    timestamp: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"activities\""
input activities_obj_rel_insert_input {
    data: activities_insert_input!
    "upsert condition"
    on_conflict: activities_on_conflict
}

"on_conflict condition type for table \"activities\""
input activities_on_conflict {
    constraint: activities_constraint!
    update_columns: [activities_update_column!]! = []
    where: activities_bool_exp
}

"Ordering options when selecting data from \"activities\"."
input activities_order_by {
    activity_assets_aggregate: activity_asset_aggregate_order_by
    created_at: order_by
    created_by: order_by
    created_by_object: users_order_by
    id: order_by
    is_hidden: order_by
    notes: order_by
    source: order_by
    task_activities_aggregate: task_activity_aggregate_order_by
    timestamp: order_by
    type: order_by
    updated_at: order_by
}

"primary key columns input for table: activities"
input activities_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"activities\""
input activities_set_input {
    created_at: timestamptz
    created_by: Int
    id: Int
    is_hidden: Boolean
    notes: String
    source: String
    timestamp: timestamptz
    type: activity_type_enum
    updated_at: timestamptz
}

"order by stddev() on columns of table \"activities\""
input activities_stddev_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"activities\""
input activities_stddev_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"activities\""
input activities_stddev_samp_order_by {
    created_by: order_by
    id: order_by
}

"Streaming cursor of the table \"activities\""
input activities_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: activities_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input activities_stream_cursor_value_input {
    created_at: timestamptz
    created_by: Int
    id: Int
    is_hidden: Boolean
    notes: String
    source: String
    timestamp: timestamptz
    type: activity_type_enum
    updated_at: timestamptz
}

"order by sum() on columns of table \"activities\""
input activities_sum_order_by {
    created_by: order_by
    id: order_by
}

input activities_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: activities_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: activities_set_input
    "filter the rows which have to be updated"
    where: activities_bool_exp!
}

"order by var_pop() on columns of table \"activities\""
input activities_var_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by var_samp() on columns of table \"activities\""
input activities_var_samp_order_by {
    created_by: order_by
    id: order_by
}

"order by variance() on columns of table \"activities\""
input activities_variance_order_by {
    created_by: order_by
    id: order_by
}

input activity_asset_aggregate_bool_exp {
    count: activity_asset_aggregate_bool_exp_count
}

input activity_asset_aggregate_bool_exp_count {
    arguments: [activity_asset_select_column!]
    distinct: Boolean
    filter: activity_asset_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"activity_asset\""
input activity_asset_aggregate_order_by {
    avg: activity_asset_avg_order_by
    count: order_by
    max: activity_asset_max_order_by
    min: activity_asset_min_order_by
    stddev: activity_asset_stddev_order_by
    stddev_pop: activity_asset_stddev_pop_order_by
    stddev_samp: activity_asset_stddev_samp_order_by
    sum: activity_asset_sum_order_by
    var_pop: activity_asset_var_pop_order_by
    var_samp: activity_asset_var_samp_order_by
    variance: activity_asset_variance_order_by
}

"input type for inserting array relation for remote table \"activity_asset\""
input activity_asset_arr_rel_insert_input {
    data: [activity_asset_insert_input!]!
    "upsert condition"
    on_conflict: activity_asset_on_conflict
}

"order by avg() on columns of table \"activity_asset\""
input activity_asset_avg_order_by {
    activity_id: order_by
    asset_id: order_by
}

"Boolean expression to filter rows from the table \"activity_asset\". All fields are combined with a logical 'AND'."
input activity_asset_bool_exp {
    _and: [activity_asset_bool_exp!]
    _not: activity_asset_bool_exp
    _or: [activity_asset_bool_exp!]
    activity: activities_bool_exp
    activity_id: Int_comparison_exp
    asset: assets_bool_exp
    asset_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"activity_asset\""
input activity_asset_inc_input {
    activity_id: Int
    asset_id: Int
}

"input type for inserting data into table \"activity_asset\""
input activity_asset_insert_input {
    activity: activities_obj_rel_insert_input
    activity_id: Int
    asset: assets_obj_rel_insert_input
    asset_id: Int
}

"order by max() on columns of table \"activity_asset\""
input activity_asset_max_order_by {
    activity_id: order_by
    asset_id: order_by
}

"order by min() on columns of table \"activity_asset\""
input activity_asset_min_order_by {
    activity_id: order_by
    asset_id: order_by
}

"on_conflict condition type for table \"activity_asset\""
input activity_asset_on_conflict {
    constraint: activity_asset_constraint!
    update_columns: [activity_asset_update_column!]! = []
    where: activity_asset_bool_exp
}

"Ordering options when selecting data from \"activity_asset\"."
input activity_asset_order_by {
    activity: activities_order_by
    activity_id: order_by
    asset: assets_order_by
    asset_id: order_by
}

"primary key columns input for table: activity_asset"
input activity_asset_pk_columns_input {
    activity_id: Int!
    asset_id: Int!
}

"input type for updating data in table \"activity_asset\""
input activity_asset_set_input {
    activity_id: Int
    asset_id: Int
}

"order by stddev() on columns of table \"activity_asset\""
input activity_asset_stddev_order_by {
    activity_id: order_by
    asset_id: order_by
}

"order by stddev_pop() on columns of table \"activity_asset\""
input activity_asset_stddev_pop_order_by {
    activity_id: order_by
    asset_id: order_by
}

"order by stddev_samp() on columns of table \"activity_asset\""
input activity_asset_stddev_samp_order_by {
    activity_id: order_by
    asset_id: order_by
}

"Streaming cursor of the table \"activity_asset\""
input activity_asset_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: activity_asset_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input activity_asset_stream_cursor_value_input {
    activity_id: Int
    asset_id: Int
}

"order by sum() on columns of table \"activity_asset\""
input activity_asset_sum_order_by {
    activity_id: order_by
    asset_id: order_by
}

input activity_asset_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: activity_asset_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: activity_asset_set_input
    "filter the rows which have to be updated"
    where: activity_asset_bool_exp!
}

"order by var_pop() on columns of table \"activity_asset\""
input activity_asset_var_pop_order_by {
    activity_id: order_by
    asset_id: order_by
}

"order by var_samp() on columns of table \"activity_asset\""
input activity_asset_var_samp_order_by {
    activity_id: order_by
    asset_id: order_by
}

"order by variance() on columns of table \"activity_asset\""
input activity_asset_variance_order_by {
    activity_id: order_by
    asset_id: order_by
}

"Boolean expression to filter rows from the table \"activity_type\". All fields are combined with a logical 'AND'."
input activity_type_bool_exp {
    _and: [activity_type_bool_exp!]
    _not: activity_type_bool_exp
    _or: [activity_type_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"activity_type_enum\". All fields are combined with logical 'AND'."
input activity_type_enum_comparison_exp {
    _eq: activity_type_enum
    _in: [activity_type_enum!]
    _is_null: Boolean
    _neq: activity_type_enum
    _nin: [activity_type_enum!]
}

"input type for inserting data into table \"activity_type\""
input activity_type_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"activity_type\""
input activity_type_on_conflict {
    constraint: activity_type_constraint!
    update_columns: [activity_type_update_column!]! = []
    where: activity_type_bool_exp
}

"Ordering options when selecting data from \"activity_type\"."
input activity_type_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: activity_type"
input activity_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"activity_type\""
input activity_type_set_input {
    comment: String
    value: String
}

"Streaming cursor of the table \"activity_type\""
input activity_type_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: activity_type_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input activity_type_stream_cursor_value_input {
    comment: String
    value: String
}

input activity_type_updates {
    "sets the columns of the filtered rows to the given values"
    _set: activity_type_set_input
    "filter the rows which have to be updated"
    where: activity_type_bool_exp!
}

"Boolean expression to filter rows from the table \"asset_category\". All fields are combined with a logical 'AND'."
input asset_category_bool_exp {
    _and: [asset_category_bool_exp!]
    _not: asset_category_bool_exp
    _or: [asset_category_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"asset_category_enum\". All fields are combined with logical 'AND'."
input asset_category_enum_comparison_exp {
    _eq: asset_category_enum
    _in: [asset_category_enum!]
    _is_null: Boolean
    _neq: asset_category_enum
    _nin: [asset_category_enum!]
}

"input type for inserting data into table \"asset_category\""
input asset_category_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"asset_category\""
input asset_category_on_conflict {
    constraint: asset_category_constraint!
    update_columns: [asset_category_update_column!]! = []
    where: asset_category_bool_exp
}

"Ordering options when selecting data from \"asset_category\"."
input asset_category_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: asset_category"
input asset_category_pk_columns_input {
    value: String!
}

"input type for updating data in table \"asset_category\""
input asset_category_set_input {
    comment: String
    value: String
}

"Streaming cursor of the table \"asset_category\""
input asset_category_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: asset_category_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input asset_category_stream_cursor_value_input {
    comment: String
    value: String
}

input asset_category_updates {
    "sets the columns of the filtered rows to the given values"
    _set: asset_category_set_input
    "filter the rows which have to be updated"
    where: asset_category_bool_exp!
}

input assets_aggregate_bool_exp {
    count: assets_aggregate_bool_exp_count
}

input assets_aggregate_bool_exp_count {
    arguments: [assets_select_column!]
    distinct: Boolean
    filter: assets_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"assets\""
input assets_aggregate_order_by {
    avg: assets_avg_order_by
    count: order_by
    max: assets_max_order_by
    min: assets_min_order_by
    stddev: assets_stddev_order_by
    stddev_pop: assets_stddev_pop_order_by
    stddev_samp: assets_stddev_samp_order_by
    sum: assets_sum_order_by
    var_pop: assets_var_pop_order_by
    var_samp: assets_var_samp_order_by
    variance: assets_variance_order_by
}

"input type for inserting array relation for remote table \"assets\""
input assets_arr_rel_insert_input {
    data: [assets_insert_input!]!
    "upsert condition"
    on_conflict: assets_on_conflict
}

"order by avg() on columns of table \"assets\""
input assets_avg_order_by {
    created_by: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"assets\". All fields are combined with a logical 'AND'."
input assets_bool_exp {
    _and: [assets_bool_exp!]
    _not: assets_bool_exp
    _or: [assets_bool_exp!]
    activity_assets: activity_asset_bool_exp
    activity_assets_aggregate: activity_asset_aggregate_bool_exp
    category: asset_category_enum_comparison_exp
    created_at: timestamptz_comparison_exp
    created_by: Int_comparison_exp
    created_by_object: users_bool_exp
    description: String_comparison_exp
    id: Int_comparison_exp
    name: String_comparison_exp
    updated_at: timestamptz_comparison_exp
    url: String_comparison_exp
}

"input type for incrementing numeric columns in table \"assets\""
input assets_inc_input {
    created_by: Int
    id: Int
}

"input type for inserting data into table \"assets\""
input assets_insert_input {
    activity_assets: activity_asset_arr_rel_insert_input
    category: asset_category_enum
    created_at: timestamptz
    created_by: Int
    created_by_object: users_obj_rel_insert_input
    description: String
    id: Int
    name: String
    updated_at: timestamptz
    url: String
}

"order by max() on columns of table \"assets\""
input assets_max_order_by {
    created_at: order_by
    created_by: order_by
    description: order_by
    id: order_by
    name: order_by
    updated_at: order_by
    url: order_by
}

"order by min() on columns of table \"assets\""
input assets_min_order_by {
    created_at: order_by
    created_by: order_by
    description: order_by
    id: order_by
    name: order_by
    updated_at: order_by
    url: order_by
}

"input type for inserting object relation for remote table \"assets\""
input assets_obj_rel_insert_input {
    data: assets_insert_input!
    "upsert condition"
    on_conflict: assets_on_conflict
}

"on_conflict condition type for table \"assets\""
input assets_on_conflict {
    constraint: assets_constraint!
    update_columns: [assets_update_column!]! = []
    where: assets_bool_exp
}

"Ordering options when selecting data from \"assets\"."
input assets_order_by {
    activity_assets_aggregate: activity_asset_aggregate_order_by
    category: order_by
    created_at: order_by
    created_by: order_by
    created_by_object: users_order_by
    description: order_by
    id: order_by
    name: order_by
    updated_at: order_by
    url: order_by
}

"primary key columns input for table: assets"
input assets_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"assets\""
input assets_set_input {
    category: asset_category_enum
    created_at: timestamptz
    created_by: Int
    description: String
    id: Int
    name: String
    updated_at: timestamptz
    url: String
}

"order by stddev() on columns of table \"assets\""
input assets_stddev_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"assets\""
input assets_stddev_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"assets\""
input assets_stddev_samp_order_by {
    created_by: order_by
    id: order_by
}

"Streaming cursor of the table \"assets\""
input assets_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: assets_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input assets_stream_cursor_value_input {
    category: asset_category_enum
    created_at: timestamptz
    created_by: Int
    description: String
    id: Int
    name: String
    updated_at: timestamptz
    url: String
}

"order by sum() on columns of table \"assets\""
input assets_sum_order_by {
    created_by: order_by
    id: order_by
}

input assets_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: assets_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: assets_set_input
    "filter the rows which have to be updated"
    where: assets_bool_exp!
}

"order by var_pop() on columns of table \"assets\""
input assets_var_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by var_samp() on columns of table \"assets\""
input assets_var_samp_order_by {
    created_by: order_by
    id: order_by
}

"order by variance() on columns of table \"assets\""
input assets_variance_order_by {
    created_by: order_by
    id: order_by
}

input task_activity_aggregate_bool_exp {
    count: task_activity_aggregate_bool_exp_count
}

input task_activity_aggregate_bool_exp_count {
    arguments: [task_activity_select_column!]
    distinct: Boolean
    filter: task_activity_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"task_activity\""
input task_activity_aggregate_order_by {
    avg: task_activity_avg_order_by
    count: order_by
    max: task_activity_max_order_by
    min: task_activity_min_order_by
    stddev: task_activity_stddev_order_by
    stddev_pop: task_activity_stddev_pop_order_by
    stddev_samp: task_activity_stddev_samp_order_by
    sum: task_activity_sum_order_by
    var_pop: task_activity_var_pop_order_by
    var_samp: task_activity_var_samp_order_by
    variance: task_activity_variance_order_by
}

"input type for inserting array relation for remote table \"task_activity\""
input task_activity_arr_rel_insert_input {
    data: [task_activity_insert_input!]!
    "upsert condition"
    on_conflict: task_activity_on_conflict
}

"order by avg() on columns of table \"task_activity\""
input task_activity_avg_order_by {
    activity_id: order_by
    task_id: order_by
}

"Boolean expression to filter rows from the table \"task_activity\". All fields are combined with a logical 'AND'."
input task_activity_bool_exp {
    _and: [task_activity_bool_exp!]
    _not: task_activity_bool_exp
    _or: [task_activity_bool_exp!]
    activity: activities_bool_exp
    activity_id: Int_comparison_exp
    task: tasks_bool_exp
    task_id: Int_comparison_exp
}

"input type for incrementing numeric columns in table \"task_activity\""
input task_activity_inc_input {
    activity_id: Int
    task_id: Int
}

"input type for inserting data into table \"task_activity\""
input task_activity_insert_input {
    activity: activities_obj_rel_insert_input
    activity_id: Int
    task: tasks_obj_rel_insert_input
    task_id: Int
}

"order by max() on columns of table \"task_activity\""
input task_activity_max_order_by {
    activity_id: order_by
    task_id: order_by
}

"order by min() on columns of table \"task_activity\""
input task_activity_min_order_by {
    activity_id: order_by
    task_id: order_by
}

"on_conflict condition type for table \"task_activity\""
input task_activity_on_conflict {
    constraint: task_activity_constraint!
    update_columns: [task_activity_update_column!]! = []
    where: task_activity_bool_exp
}

"Ordering options when selecting data from \"task_activity\"."
input task_activity_order_by {
    activity: activities_order_by
    activity_id: order_by
    task: tasks_order_by
    task_id: order_by
}

"primary key columns input for table: task_activity"
input task_activity_pk_columns_input {
    activity_id: Int!
    task_id: Int!
}

"input type for updating data in table \"task_activity\""
input task_activity_set_input {
    activity_id: Int
    task_id: Int
}

"order by stddev() on columns of table \"task_activity\""
input task_activity_stddev_order_by {
    activity_id: order_by
    task_id: order_by
}

"order by stddev_pop() on columns of table \"task_activity\""
input task_activity_stddev_pop_order_by {
    activity_id: order_by
    task_id: order_by
}

"order by stddev_samp() on columns of table \"task_activity\""
input task_activity_stddev_samp_order_by {
    activity_id: order_by
    task_id: order_by
}

"Streaming cursor of the table \"task_activity\""
input task_activity_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: task_activity_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input task_activity_stream_cursor_value_input {
    activity_id: Int
    task_id: Int
}

"order by sum() on columns of table \"task_activity\""
input task_activity_sum_order_by {
    activity_id: order_by
    task_id: order_by
}

input task_activity_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: task_activity_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: task_activity_set_input
    "filter the rows which have to be updated"
    where: task_activity_bool_exp!
}

"order by var_pop() on columns of table \"task_activity\""
input task_activity_var_pop_order_by {
    activity_id: order_by
    task_id: order_by
}

"order by var_samp() on columns of table \"task_activity\""
input task_activity_var_samp_order_by {
    activity_id: order_by
    task_id: order_by
}

"order by variance() on columns of table \"task_activity\""
input task_activity_variance_order_by {
    activity_id: order_by
    task_id: order_by
}

"Boolean expression to filter rows from the table \"task_status\". All fields are combined with a logical 'AND'."
input task_status_bool_exp {
    _and: [task_status_bool_exp!]
    _not: task_status_bool_exp
    _or: [task_status_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"task_status_enum\". All fields are combined with logical 'AND'."
input task_status_enum_comparison_exp {
    _eq: task_status_enum
    _in: [task_status_enum!]
    _is_null: Boolean
    _neq: task_status_enum
    _nin: [task_status_enum!]
}

"input type for inserting data into table \"task_status\""
input task_status_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"task_status\""
input task_status_on_conflict {
    constraint: task_status_constraint!
    update_columns: [task_status_update_column!]! = []
    where: task_status_bool_exp
}

"Ordering options when selecting data from \"task_status\"."
input task_status_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: task_status"
input task_status_pk_columns_input {
    value: String!
}

"input type for updating data in table \"task_status\""
input task_status_set_input {
    comment: String
    value: String
}

"Streaming cursor of the table \"task_status\""
input task_status_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: task_status_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input task_status_stream_cursor_value_input {
    comment: String
    value: String
}

input task_status_updates {
    "sets the columns of the filtered rows to the given values"
    _set: task_status_set_input
    "filter the rows which have to be updated"
    where: task_status_bool_exp!
}

input tasks_aggregate_bool_exp {
    count: tasks_aggregate_bool_exp_count
}

input tasks_aggregate_bool_exp_count {
    arguments: [tasks_select_column!]
    distinct: Boolean
    filter: tasks_bool_exp
    predicate: Int_comparison_exp!
}

"order by aggregate values of table \"tasks\""
input tasks_aggregate_order_by {
    avg: tasks_avg_order_by
    count: order_by
    max: tasks_max_order_by
    min: tasks_min_order_by
    stddev: tasks_stddev_order_by
    stddev_pop: tasks_stddev_pop_order_by
    stddev_samp: tasks_stddev_samp_order_by
    sum: tasks_sum_order_by
    var_pop: tasks_var_pop_order_by
    var_samp: tasks_var_samp_order_by
    variance: tasks_variance_order_by
}

"input type for inserting array relation for remote table \"tasks\""
input tasks_arr_rel_insert_input {
    data: [tasks_insert_input!]!
    "upsert condition"
    on_conflict: tasks_on_conflict
}

"order by avg() on columns of table \"tasks\""
input tasks_avg_order_by {
    created_by: order_by
    id: order_by
}

"Boolean expression to filter rows from the table \"tasks\". All fields are combined with a logical 'AND'."
input tasks_bool_exp {
    _and: [tasks_bool_exp!]
    _not: tasks_bool_exp
    _or: [tasks_bool_exp!]
    created_at: timestamptz_comparison_exp
    created_by: Int_comparison_exp
    created_by_object: users_bool_exp
    desc: String_comparison_exp
    id: Int_comparison_exp
    status: task_status_enum_comparison_exp
    task_activities: task_activity_bool_exp
    task_activities_aggregate: task_activity_aggregate_bool_exp
    title: String_comparison_exp
    updated_at: timestamptz_comparison_exp
}

"input type for incrementing numeric columns in table \"tasks\""
input tasks_inc_input {
    created_by: Int
    id: Int
}

"input type for inserting data into table \"tasks\""
input tasks_insert_input {
    created_at: timestamptz
    created_by: Int
    created_by_object: users_obj_rel_insert_input
    desc: String
    id: Int
    status: task_status_enum
    task_activities: task_activity_arr_rel_insert_input
    title: String
    updated_at: timestamptz
}

"order by max() on columns of table \"tasks\""
input tasks_max_order_by {
    created_at: order_by
    created_by: order_by
    desc: order_by
    id: order_by
    title: order_by
    updated_at: order_by
}

"order by min() on columns of table \"tasks\""
input tasks_min_order_by {
    created_at: order_by
    created_by: order_by
    desc: order_by
    id: order_by
    title: order_by
    updated_at: order_by
}

"input type for inserting object relation for remote table \"tasks\""
input tasks_obj_rel_insert_input {
    data: tasks_insert_input!
    "upsert condition"
    on_conflict: tasks_on_conflict
}

"on_conflict condition type for table \"tasks\""
input tasks_on_conflict {
    constraint: tasks_constraint!
    update_columns: [tasks_update_column!]! = []
    where: tasks_bool_exp
}

"Ordering options when selecting data from \"tasks\"."
input tasks_order_by {
    created_at: order_by
    created_by: order_by
    created_by_object: users_order_by
    desc: order_by
    id: order_by
    status: order_by
    task_activities_aggregate: task_activity_aggregate_order_by
    title: order_by
    updated_at: order_by
}

"primary key columns input for table: tasks"
input tasks_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"tasks\""
input tasks_set_input {
    created_at: timestamptz
    created_by: Int
    desc: String
    id: Int
    status: task_status_enum
    title: String
    updated_at: timestamptz
}

"order by stddev() on columns of table \"tasks\""
input tasks_stddev_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_pop() on columns of table \"tasks\""
input tasks_stddev_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by stddev_samp() on columns of table \"tasks\""
input tasks_stddev_samp_order_by {
    created_by: order_by
    id: order_by
}

"Streaming cursor of the table \"tasks\""
input tasks_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: tasks_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input tasks_stream_cursor_value_input {
    created_at: timestamptz
    created_by: Int
    desc: String
    id: Int
    status: task_status_enum
    title: String
    updated_at: timestamptz
}

"order by sum() on columns of table \"tasks\""
input tasks_sum_order_by {
    created_by: order_by
    id: order_by
}

input tasks_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: tasks_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: tasks_set_input
    "filter the rows which have to be updated"
    where: tasks_bool_exp!
}

"order by var_pop() on columns of table \"tasks\""
input tasks_var_pop_order_by {
    created_by: order_by
    id: order_by
}

"order by var_samp() on columns of table \"tasks\""
input tasks_var_samp_order_by {
    created_by: order_by
    id: order_by
}

"order by variance() on columns of table \"tasks\""
input tasks_variance_order_by {
    created_by: order_by
    id: order_by
}

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
    _eq: timestamptz
    _gt: timestamptz
    _gte: timestamptz
    _in: [timestamptz!]
    _is_null: Boolean
    _lt: timestamptz
    _lte: timestamptz
    _neq: timestamptz
    _nin: [timestamptz!]
}

"Boolean expression to filter rows from the table \"user_role\". All fields are combined with a logical 'AND'."
input user_role_bool_exp {
    _and: [user_role_bool_exp!]
    _not: user_role_bool_exp
    _or: [user_role_bool_exp!]
    comment: String_comparison_exp
    value: String_comparison_exp
}

"Boolean expression to compare columns of type \"user_role_enum\". All fields are combined with logical 'AND'."
input user_role_enum_comparison_exp {
    _eq: user_role_enum
    _in: [user_role_enum!]
    _is_null: Boolean
    _neq: user_role_enum
    _nin: [user_role_enum!]
}

"input type for inserting data into table \"user_role\""
input user_role_insert_input {
    comment: String
    value: String
}

"on_conflict condition type for table \"user_role\""
input user_role_on_conflict {
    constraint: user_role_constraint!
    update_columns: [user_role_update_column!]! = []
    where: user_role_bool_exp
}

"Ordering options when selecting data from \"user_role\"."
input user_role_order_by {
    comment: order_by
    value: order_by
}

"primary key columns input for table: user_role"
input user_role_pk_columns_input {
    value: String!
}

"input type for updating data in table \"user_role\""
input user_role_set_input {
    comment: String
    value: String
}

"Streaming cursor of the table \"user_role\""
input user_role_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: user_role_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_role_stream_cursor_value_input {
    comment: String
    value: String
}

input user_role_updates {
    "sets the columns of the filtered rows to the given values"
    _set: user_role_set_input
    "filter the rows which have to be updated"
    where: user_role_bool_exp!
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
    _and: [users_bool_exp!]
    _not: users_bool_exp
    _or: [users_bool_exp!]
    activities: activities_bool_exp
    activities_aggregate: activities_aggregate_bool_exp
    assets: assets_bool_exp
    assets_aggregate: assets_aggregate_bool_exp
    created_at: timestamptz_comparison_exp
    id: Int_comparison_exp
    last_login: timestamptz_comparison_exp
    name: String_comparison_exp
    password: String_comparison_exp
    role: user_role_enum_comparison_exp
    tasks: tasks_bool_exp
    tasks_aggregate: tasks_aggregate_bool_exp
    updated_at: timestamptz_comparison_exp
    username: String_comparison_exp
}

"input type for incrementing numeric columns in table \"users\""
input users_inc_input {
    id: Int
}

"input type for inserting data into table \"users\""
input users_insert_input {
    activities: activities_arr_rel_insert_input
    assets: assets_arr_rel_insert_input
    created_at: timestamptz
    id: Int
    last_login: timestamptz
    name: String
    password: String
    role: user_role_enum
    tasks: tasks_arr_rel_insert_input
    updated_at: timestamptz
    username: String
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
    data: users_insert_input!
    "upsert condition"
    on_conflict: users_on_conflict
}

"on_conflict condition type for table \"users\""
input users_on_conflict {
    constraint: users_constraint!
    update_columns: [users_update_column!]! = []
    where: users_bool_exp
}

"Ordering options when selecting data from \"users\"."
input users_order_by {
    activities_aggregate: activities_aggregate_order_by
    assets_aggregate: assets_aggregate_order_by
    created_at: order_by
    id: order_by
    last_login: order_by
    name: order_by
    password: order_by
    role: order_by
    tasks_aggregate: tasks_aggregate_order_by
    updated_at: order_by
    username: order_by
}

"primary key columns input for table: users"
input users_pk_columns_input {
    id: Int!
}

"input type for updating data in table \"users\""
input users_set_input {
    created_at: timestamptz
    id: Int
    last_login: timestamptz
    name: String
    password: String
    role: user_role_enum
    updated_at: timestamptz
    username: String
}

"Streaming cursor of the table \"users\""
input users_stream_cursor_input {
    "Stream column input with initial value"
    initial_value: users_stream_cursor_value_input!
    "cursor ordering"
    ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input users_stream_cursor_value_input {
    created_at: timestamptz
    id: Int
    last_login: timestamptz
    name: String
    password: String
    role: user_role_enum
    updated_at: timestamptz
    username: String
}

input users_updates {
    "increments the numeric columns with given value of the filtered values"
    _inc: users_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: users_set_input
    "filter the rows which have to be updated"
    where: users_bool_exp!
}
